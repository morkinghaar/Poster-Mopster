'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

exports.default = render;

var _react = require('react');

var _react2 = _interopRequireDefault(_react);

var _reactDom = require('react-dom');

var _reactDom2 = _interopRequireDefault(_reactDom);

var _getReactRouterRoute = require('./router-traversal/getReactRouterRoute');

var _getReactRouterRoute2 = _interopRequireDefault(_getReactRouterRoute);

var _addPropsToRouter = require('./addPropsToRouter');

var _addPropsToRouter2 = _interopRequireDefault(_addPropsToRouter);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Render the given routes to the given container.
 *
 * @param routes      {ReactRouterRoute}      The router to render
 * @param container   {DOMElement}            Same as second argument to 'ReactDOM.render'
 * @param ...propArgs {Array<Object | Func>}  All arguments after routes is used to add props to the top-level
 *                                            components in the router. If given as a function, it will be called
 *                                            when the component is rendered or updated.
 *
 * @return            {ReactComponent}        The render componet (see return of 'React.render')
 */
function render(routes, container) {
  for (var _len = arguments.length, propArgs = Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
    propArgs[_key - 2] = arguments[_key];
  }

  // Check args
  if (!routes) throw new Error('Route is required to render');
  if (!container) throw new Error('A container is required to render');

  // Parse routes
  var parsedRoutes = (0, _getReactRouterRoute2.default)(routes);

  // Render current route
  if (!propArgs || propArgs.length === 0) {
    return _reactDom2.default.render(parsedRoutes, container);
  } else {
    var _ret = function () {
      // Split up static and dynamic props
      var staticProps = {};
      var dynamicPropFuncs = propArgs.filter(function (propArg) {
        if (typeof propArg === 'function') return true;

        staticProps = _extends({}, staticProps, propArg);
        return false;
      });

      if (dynamicPropFuncs.length === 0) {
        var routesWithProps = (0, _addPropsToRouter2.default)(routes, staticProps);

        return {
          v: _reactDom2.default.render(routesWithProps, container)
        };
      } else {
        return {
          v: renderWithProps(parsedRoutes, container, staticProps, function () {
            var props = {};
            dynamicPropFuncs.forEach(function (getProps) {
              props = _extends({}, props, getProps());
            });
            return props;
          })
        };
      }
    }();

    if ((typeof _ret === 'undefined' ? 'undefined' : _typeof(_ret)) === "object") return _ret.v;
  }
}

function renderWithProps(routes, container, staticProps, getDynamicProps) {
  // Add props to the router
  var routesWithProps = (0, _addPropsToRouter2.default)(routes, staticProps, getDynamicProps);

  // Recall this function if callback is called (skip first to avoid infinite loop)
  var hasRenderedBefore = false;
  var renderCallback = function renderCallback() {
    if (hasRenderedBefore) renderWithProps(routes, container, staticProps, getDynamicProps);else hasRenderedBefore = true;
  };

  return _reactDom2.default.render(routesWithProps, container, renderCallback);
}